---
title: <center><font size="7"><b><i>ohun</i>&#x3A; optimizing acoustic signal detection</b></font></center>
pagetitle: Introduction to warbleR
author: 
- <center><a href="https://marceloarayasalas.weebly.com">Marcelo Araya-Salas, PhD</a></center>
date:  <center>"`r Sys.Date()`"</center>
output:
  rmarkdown::html_document:
    self_contained: yes
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: true
vignette: >
   %\VignetteIndexEntry{1. Introduction to ohun}
   %\usepackage[utf8]{inputenc}
   %\VignetteEncoding{UTF-8}
   %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

<!-- <script> -->
<!--    $(document).ready(function() { -->
<!--      $head = $('#header'); -->
<!--      $head.prepend('<img src=\"logo.png\"/>') -->
<!--    }); -->
<!-- </script> -->

<!-- &nbsp;  -->

&nbsp; 

[ohun](https://github.com/maRce10/ohun) is intended to facilitate the automatic detection of acoustic signals, providing functions to diagnose and optimize detection routines. Detections from other software can also be explored and optimized.

&nbsp; 

<div class="alert alert-info">

<font size = "4">The main features of the package are: </font>

- The use of reference annotations for detection optimization and diagnostic 
- The use of signal detection theory indices to evaluate detection performance 
- Batch processing of sound files for improving computational performance

&nbsp;

<font size = "4">The package offers functions for: </font>

- Diagnose detection performance
- Optimize detection routines based on reference annotations
- Energy-based detection
- Template-based detection

</div>



All functions allow the parallelization of tasks, which distributes the tasks among several processors to improve computational efficiency. The package works on sound files in '.wav', '.mp3', '.flac' and '.wac' format.

--- 

To install the latest developmental version from [github](https://github.com/) you will need the R package [devtools](https://cran.r-project.org/package=devtools):
```{r, eval = FALSE}

# install pacakge
devtools::install_github("maRce10/ohun")

#load package
library(ohun)

```

```{r global options, echo = FALSE, message=FALSE, warning=FALSE}

source("~/Dropbox/R_package_testing/ohun/R/template_detector.R")
source("~/Dropbox/R_package_testing/ohun/R/label_spectro.R")
#load package
library(ohun)

load("../data/lbh2.rda")
load("../data/lbh1.rda")
load("../data/lbh_reference.rda")

# for spectrograms
par(mar = c(5, 4, 2, 2) + 0.1)

# align figures
opts_chunk$set(tidy = TRUE, fig.height=4.5, fig.width=10, warning = FALSE, message = FALSE) 
```
&nbsp;

---

# Automatic signal detection

Finding the position of signals in a sound file is a challenging task. [ohun](https://github.com/maRce10/ohun) offers two methods for automatic signal detection: template-based and energy-based detection. These methods are better suited for highly stereotyped or good signal-to-noise ratio (SNR) signals, respectively. If the target signals don't fit these requirements, more elaborated methods (i.e. machine learning approaches) are warranted: 

 <center><img src="analysis_workflow.png" alt="automatic signal detection diagram" width="500" height="450"></center>

&nbsp; 

Still, a detection run using other software can be optimized with the tools provided in [ohun](https://github.com/maRce10/ohun). 

&nbsp; 

#  Signal detection theory applied to bioacoustics  

Broadly speaking, signal detection theory deals with the process of recovering signals (i.e. target signals) from background noise (not necessarily acoustic noise) and it's widely used for optimizing this decision making process in the presence of uncertainty. During a detection routine, the detected 'items' can be classified into 4 classes:

- **True positives (TPs)**: signals correctly identified as 'signal'
- **False positives (FPs)**: background noise incorrectly identified as 'signal'
- **False negatives (FNs)**: signals incorrectly identified as 'background noise'
- **True negatives (TNs)**: background noise correctly identified as 'background noise'

Several additional indices derived from these indices are used to evaluate the performance of a detection routine. These are two useful indices in the context of acoustic signal detection included in [ohun](https://github.com/maRce10/ohun):

- **Sensitivity**: proportion of target signals that were detected (a.k.a. true positive rate or recall; *TPs / (TPs + FNs)*)
- **Specificity**: proportion of detected items that correspond to target signals (*(TPs + FNs) / (TPs + FPs)*). This definition differs from more traditional ones that focus on true negative occurrences. In our case it refers to the specificity to target signals.

<font size = "2">*(Metrics that make use of 'true negatives' cannot be easily applied in the context of acoustic signal detection as noise cannot always be partitioned in discrete units)*</font>

A perfect detection will have no false positives or false negatives, which will result in both sensitivity and specificity equal to 1. However, perfect detection cannot always be reached and some compromise between detecting all target signals plus some noise (sensitivity = 1 & specificity < 1) and detecting only target signals but not all of them (sensitivity < 1 & specificity = 1) is warranted. The right balance between these two extremes will be given by the relative costs of missing signals and mistaking noise for signals. Hence, these indices provide an useful framework for diagnosing and optimizing the performance of a detection routine. 

The package [ohun](https://github.com/maRce10/ohun) provides a set of tools to evaluate the performance of an acoustic signal detection based on the indices described above. To accomplish this, the result of a detection routine is compared against a reference table containing the time position of all target signals in the sound files. The package comes with an example reference table containing annotations of long-billed hermit hummingbird songs from two sound files (also supplied as example data: 'lbh1' and 'lbh2'), which can be used to illustrate detection performance evaluation. The example data can be explored as follows:  
```{r, eval = TRUE, }
# load example data
data("lbh1", "lbh2", "lbh_reference")

lbh_reference
```
&nbsp;

This is a 'selection table', an object class provided by the package [warbleR](https://CRAN.R-project.org/package=warbleR) (see  see [`selection_table`](https://marce10.github.io/warbleR/reference/selection_table.html) for more details). Selection tables are basically data frames in which the contained information has been double-checked (using [`selection_table`](https://marce10.github.io/warbleR/reference/check_sels.html)). But they behave pretty much as data frames and can be easily converted to data frames:

```{r}
# convert to data frame
as.data.frame(lbh_reference)
```
&nbsp;

All [ohun](https://github.com/maRce10/ohun) functions that work with this kind of data can take both selection tables and data frames. Spectrograms with highlighted signals from a selection table can be plotted with the function `label_spectro()` (this function only plots one wave object at the time):
```{r, eval = TRUE}
# save sound file
writeWave(lbh1, file.path(tempdir(), "lbh1.wav"))

# save sound file
writeWave(lbh2, file.path(tempdir(), "lbh2.wav"))

# print spectrogram
label_spectro(wave = lbh1, reference = lbh_reference[lbh_reference$sound.files == "lbh1.wav", ], hop.size = 10, ovlp = 50, flim = c(1, 10))

# print spectrogram
label_spectro(wave = lbh2, reference = lbh_reference[lbh_reference$sound.files == "lbh2.wav", ], hop.size = 10, ovlp = 50, flim = c(1, 10))
```

The function `diagnose_detection()` evaluates the performance of a detection routine by comparing it to a reference table. For instance, a perfect detection is given by comparing `lbh_reference` to itself:
```{r}

lbh1_reference <- lbh_reference[lbh_reference$sound.files == "lbh1.wav", ]

# diagnose
diagnose_detection(reference = lbh1_reference, detection = lbh1_reference)[, c(1:3, 7:8)]

```
&nbsp;

We will work mostly with a single sound file for convenience but the functions can work on several sound files at the time. The files should be found in a single working directory. Although the above example is a bit silly, it shows the basic diagnostic indices, which include basic detection theory indices ('true.positives', 'false.positives', 'false.negatives', 'sensitivity' and 'specificity') mentioned above. We can play around with the reference table to see how these indices can be used to spot imperfect detection routines (and hopefully improve them!). For instance, we can remove some signals to see how this is reflected in the diagnostics. Getting rid of some rows in 'detection', simulating a detection with some false negatives, will affect the sensitivity but not the specificity:
```{r}

# create new table
lbh1_detection <- lbh1_reference[3:9, ]

# print spectrogram
label_spectro(wave = lbh1, reference = lbh1_reference, detection = lbh1_detection, hop.size = 10, ovlp = 50, flim = c(1, 10))

# diagnose
diagnose_detection(reference = lbh1_reference, detection = lbh1_detection)[, c(1:3, 7:8)]

```
&nbsp;

Having some additional signals not in reference will do the opposite, reducing specificity but not sensitivity. We can do this simply by switching the tables:
```{r, }

# print spectrogram
label_spectro(wave = lbh1, detection = lbh1_reference, reference = lbh1_detection, hop.size = 10, ovlp = 50, flim = c(1, 10))

# diagnose
diagnose_detection(reference = lbh1_detection, detection = lbh1_reference)[, c(1:3, 7:8)]

```
&nbsp;

The function offers three additional diagnose metrics: 

- **Split positives**: target signals overlapped by more than 1 detecion 
- **Merged positives**: number of cases in which 2 or more target signals in 'reference' were overlapped by the same detection
- **Proportional overlap of true positives**: ratio of the time overlap of true positives with its corresponding signal in the reference table

In a perfect detection routine split and merged positives should be 0 while proportional overlap should be 1. We can shift the start of signals a bit to reflect a detection in which there is some mismatch to the reference table regarding to the time location of signals:
```{r, }

# create new table
lbh1_detection <- lbh1_reference

# add 'noise' to start
set.seed(18)
lbh1_detection$start <- lbh1_detection$start + rnorm(nrow(lbh1_detection),mean = 0, sd = 0.1)

## print spectrogram
label_spectro(wave = lbh1, reference = lbh1_reference, detection = lbh1_detection, hop.size = 10, ovlp = 50, flim = c(1, 10))

# diagnose
diagnose_detection(reference = lbh1_reference, detection = lbh1_detection)

```
&nbsp;

In addition, the following diagnostics related to the duration of the signals can also be returned by setting `time.diagnostics = TRUE`. Here we tweak the reference and detection data just to have some false positives and false negatives:
```{r}

# diagnose with time diagnostics
diagnose_detection(reference = lbh1_reference[-1, ], detection = lbh1_detection[-10, ], time.diagnostics = TRUE)

```
&nbsp;

These additional metrics can be used to further filter out undesired signals based on their duration (for instance in a energy-based detection as in `energy_detector()`, explained below). 

Diagnostics can also be detailed by sound file:
```{r}
# diagnose by sound file
diagnostic <- diagnose_detection(reference = lbh1_reference, detection = lbh1_detection, by.sound.file = TRUE)

diagnostic
```
&nbsp;

These diagnostics can be summarized (as in the default `diagnose_detection()` output) with the function `summarize_diagnostic()`:
```{r}

# summarize
summarize_diagnostic(diagnostic)

```
&nbsp;

# Detecting signals with *ohun*

## Energy-based detection

This detector uses amplitude envelopes to infer the position of signals. Amplitude envelopes are representations of the variation in energy through time. The following code plots an amplitude envelope along with the spectrogram for the example data `lbh1`:
```{r, }

# plot spectrogram and envelope
label_spectro(wave = cutw(lbh1, from = 0, to = 1.5, output = "Wave"), ovlp = 90, hop.size = 10, flim = c(0, 10), envelope = TRUE)

```
&nbsp;

This type of detector doesn't require highly stereotyped signals, although they work better on high quality recordings in which the amplitude of target signals is higher than the background noise (i.e. high signal-to-noise ratio). The function `ernergy_detector()` performs this type of detection.

&nbsp;

### How it works 

We can understand how to use `ernergy_detector()` using simulated signals. We will do that using the function `simulate_songs()` from [warbleR](https://CRAN.R-project.org/package=warbleR). In this example we simulate a recording with 10 sounds with two different frequency ranges and durations:
```{r}

# install this package first if not installed
# install.packages("Sim.DiffProc")

#Creating vector for duration 
durs <- rep(c(0.3, 1), 5)

#Creating simulated song
set.seed(12)
simulated_1 <- warbleR::simulate_songs(n = 10, durs = durs, freqs = 5, sig2 = 0.01, gaps = 0.5, harms = 1, bgn = 0.1, path = tempdir(), file.name = "simulated_1", selec.table = TRUE, shape = "cos", fin = 0.3, fout = 0.35, samp.rate = 18)$wave

```
&nbsp;

The function call saves a '.wav' sound file in a temporary directory (`tempdir()`) and also returns a `wave` object in the R environment. This outputs will be used to run energy-based detection and creating plots, respectively. This is how the spectrogram and amplitude envelope of the simulated recording look like:
```{r, fig.height=4, fig.width=10}

# plot spectrogram and envelope
label_spectro(wave = simulated_1, env = TRUE, fastdisp = TRUE)

```
&nbsp;

Note that the amplitude envelope shows a high signal-to-noise ratio of the signals, which is ideal for energy-based detection. This can be conducted using `ernergy_detector()` as follows:

```{r, fig.height=4, fig.width=10}

# run detection
detection <- energy_detector(files = "simulated_1.wav", bp = c(2, 8), threshold = 50, smooth = 150, path = tempdir())

# plot spectrogram and envelope
label_spectro(wave = simulated_1, envelope = TRUE,  detection = detection, threshold = 50)

```
&nbsp;

The output is a selection table:

```{r}

detection

```


Now we will make use of some additional arguments to filter out specific signals based on their structural features. For instance we can use the argument `minimum.duration` to provide a time treshold (in ms) to exclude short signals and keep only the longest signals:
```{r eval = TRUE, echo = TRUE, fig.height=4, fig.width=10}

# run detection
detection <- energy_detector(files = "simulated_1.wav", bp = c(1, 8), threshold = 50, min.duration = 500, smooth = 150, path = tempdir())

# plot spectrogram
label_spectro(wave = simulated_1, detection = detection)

```
&nbsp;

We can use the argument `max.duration` (also in ms) to exclude long signals and keep the short ones:
```{r eval = TRUE, echo = TRUE, fig.height=4, fig.width=10}

# run detection
detection <- energy_detector(files = "simulated_1.wav", bp = c(1, 8),  threshold = 50, smooth = 150, max.duration = 500, path = tempdir())

# plot spectrogram
label_spectro(wave = simulated_1,  detection = detection)

```
&nbsp;

We can also focus the detection on specific frequency ranges using the argument `bp` (bandpass). By setting `bp = c(5, 8)` only those signals found within that frequency range (5-8 kHz) will be detected, which excludes signals below 5 kHz:
```{r, fig.height=4, fig.width=10, eval = TRUE, echo = TRUE}

# Detecting 
detection <- energy_detector(files = "simulated_1.wav", bp = c(5, 8), threshold = 50, smooth = 150, path = tempdir())

# plot spectrogram
label_spectro(wave = simulated_1,  detection = detection)

```
&nbsp;

The same logic can be applied to detect those signals found below 5 kHz. We just need to set the upper bound of the band pass filter below the range of the higher frequency signals (for instance `bp = (0, 6)`):
```{r, fig.height=4, fig.width=10, eval = TRUE, echo = TRUE}

# Detect
detection <- energy_detector(files = "simulated_1.wav", bp = c(0, 6), threshold = 50, min.duration = 1, smooth = 150, path = tempdir())

# plot spectrogram
label_spectro(wave = simulated_1,  detection = detection)

```
&nbsp;

Amplitude modulation (variation in amplitude across a signal) can be problematic for detection based on amplitude envelopes. We can also simulate some amplitude modulation using `warbleR::simulate_songs()`:
```{r, eval = TRUE, warning=FALSE, message=FALSE}

#Creating simulated song
set.seed(12)
sim_2 <- sim_songs(n = 10, durs = durs, freqs = 5, sig2 = 0.01, gaps = 0.5, harms = 1, bgn = 0.1, path = tempdir(), file.name = "simulated_2", selec.table = TRUE, shape = "cos", fin = 0.3, fout = 0.35, samp.rate = 18, am.amps = c(1, 2, 3, 2, 0.1, 2, 3, 3, 2, 1))

# extract wave object and selection table
simulated_2 <- sim_2$wave
sim2_sel_table <- sim_2$selec.table

# plot spectrogram
label_spectro(wave = simulated_2, envelope = TRUE)

```
&nbsp;

When signals have strong amplitude modulation they can be split during detection:
```{r, eval = TRUE}

# detect sounds
detection <- energy_detector(files = "simulated_2.wav", threshold = 50, path = tempdir())

# plot spectrogram
label_spectro(wave = simulated_2, envelope = TRUE, threshold = 50, detection = detection)

```
&nbsp;

There are two arguments that can deal with this: `holdtime` and `smooth`. `hold.time` allows to merge split signals that are found within a given time range (in ms). This time range should be high enough to merge things belonging to the same signal but not too high so it merges different signals. For this example a `hold.time` of 200 ms can do the trick (we know gaps between signals are ~0.5 s long):
```{r, eval = TRUE}

# detect sounds
detection <- energy_detector(files = "simulated_2.wav", threshold = 50, min.duration = 1, path = tempdir(), hold.time = 200)

# plot spectrogram
label_spectro(wave = simulated_2, envelope = TRUE, threshold = 50, detection = detection)

```
&nbsp;

`smooth` works by merging the amplitude envelope 'hills' of the split signals themselves. It smooths envelopes by applying a sliding window averaging of amplitude values. It's given in ms of the window size. A `smooth` of 350 ms can merged back split signals from our example:  

```{r, eval = TRUE}

# detect sounds
detection <- energy_detector(files = "simulated_2.wav", threshold = 50, min.duration = 1, path = tempdir(), smooth = 350)

# plot spectrogram
label_spectro(wave = simulated_2, envelope = TRUE, threshold = 50, detection = detection, smooth = 350)

```
&nbsp;

### Optimizing energy-based detection

This last example using `smooth` can be used to showcase how the tunning parameters can be optimized. As explained above, to do this we need a reference table that contains the time position of the target signals. The function `optimize_energy_detector()` can be used finding the optimal parameter values. We must provide the range of parameter values that will be evaluated:

```{r}

optimize_energy_detector(reference = sim2_sel_table, files = "simulated_2.wav", threshold = 50, min.duration = 1, path = tempdir(), smooth = c(100, 250, 350))[, c(1, 3:6, 8:13, 18:19)]

```
&nbsp;

The output contains the combination of parameters used at each iteration as well as the corresponding diagnose indices. In this case all combinations generate a good detection (sensitivity & specificity = 1). However, only the routine with the highest `smooth` (last row) has no split signals ('split.positive' column). It also shows a better overlap to the reference signals ('proportional.overlap.true.positives' closer to 1).

## Template-based detection

This detection method is better suited for highly stereotyped signals. As it doesn't depend on the signal-to-noise ratio it's more robust to higher levels of background noise. The procedure is divided in two steps:

- Estimating the cross-correlation scores of templates along sound files (`template_correlator()`)  
- Detecting signals by applying a correlation threshold (`template_detector()`)  

This method can be used to detect the signals in the example 'lbh1' data as follows:
```{r}

# get correlations 
correlations <- template_correlator(templates = lbh1_reference[1, ], files = "lbh1.wav", path = tempdir())

```
&nbsp;

The output is an object of class 'template_correlations', with its own printing method:
```{r}

# print
correlations

```
&nbsp;

This object can then be used to detect signals using `template_detector()`:
```{r}

# run detection 
detection <- template_detector(template.correlations = correlations, threshold = 0.4)

detection
```
&nbsp;

The output can be explored by plotting the spectrogram along with the detection and correlation scores:
```{r, warning=FALSE}

# plot spectrogram
label_spectro(wave = lbh1, detection = detection, template.correlation = correlations$`lbh1.wav-10/lbh1.wav`, flim = c(0, 10), threshold = 0.4, hop.size = 10, ovlp = 50)

```
&nbsp;

The performance can be evaluated using `diagnose_detection()`:
```{r}

#diagnose
diagnose_detection(reference = lbh1_reference, detection = detection)

```
&nbsp;

### Optimizing template-based detection

The function `optimize_template_detector()` allows to evaluate the performance under different correlation thresholds:

```{r}

# run optimization
optimization <- optimize_template_detector(template.correlations = correlations, reference = lbh1_reference, threshold = seq(0.1, 0.5, 0.1))

# print output
optimization
```
&nbsp;

Additional threshold values can be evaluated without having to run it all over again. We just need to supplied the output from the previous run with the argument `previous.output` (the same trick can be done when optimizing an energy-based detection):
```{r}

# run optimization
optimize_template_detector(template.correlations = correlations, reference = lbh1_reference, threshold = c(0.6, 0.7), previous.output = optimization)

```
&nbsp;

In this case several threshold values can achieved an optimal detection.

&nbsp;

### Detecting several templates

Several templates can be used within the same call. Here we correlate two templates on the two example sound files, taking one template from each sound file:
```{r}

# get correlations
correlations <- template_correlator(templates = lbh_reference[c(1, 10), ], files = c("lbh1.wav", "lbh2.wav"), path = tempdir())

# run detection 
detection <- template_detector(template.correlations = correlations, threshold = 0.5)

```
&nbsp;

Note that in these cases we can get the same signal detected several times (duplicates), one by each template. We can check if that is the case just by diagnosing the detection:
```{r}

#diagnose
diagnose_detection(reference = lbh_reference, detection = detection)

```
&nbsp;

Duplicates are shown as split positives. Fortunately, we can leave a single detected signal by leaving only those with the highest correlation. To do this we first need to label each row in the detection using `label_detection()` and then remove duplicates using `filter_detection()`:
```{r}

# labeling detection
labeled <- label_detection(reference = lbh_reference, detection = detection)

```

This function adds a column ('detection.class') with the class label for each row:
```{r}

table(labeled$detection.class)

```
&nbsp;

Now we can filter out duplicates and diagnose the detection again, telling the function to select a single row per duplicate using the correlation score as a criterium (`by = "scores"`, this column is part of the `template_detector()` output):
```{r}
# filter
filtered <- filter_detection(detection = labeled, by = "scores")

# diagnose
diagnose_detection(reference = lbh_reference, detection = filtered)
```
&nbsp;

We successfully get rid of duplicates and detected every single target signal.

---

## Improving detection speed

Detection routines can take a long time when working with large amounts of acoustic data (e.g. large sound files and/or many sound files). These are some useful points to keep in mine when trying to make a routine more time-efficient:

- Always test procedures on small data subsets
- `template_detector()` is faster than `energy_detector()`
- Parallelization (see `parallel` argument in most functions) can significantly speed-up routines, but works better on Unix-based operating systems (linux and mac OS)
- Sampling rate matters: detecting signals on low sampling rate files goes faster, so we should avoid having nyquist frequencies (sampling rate / 2) way higher than the highest frequency of the target signals (sound files can be downsampled using warbleR's [`fix_sound_files()`](https://marce10.github.io/warbleR/reference/selection_table.html))
- Large sound files can make the routine crash, use `split_acoustic_data()` to split both reference tables and files into shorter clips.
- Think about using a computer with lots of RAM memory or a computer cluster for working on large amounts of data
- `thinning` argument (which reduces the size of the amplitude envelope) can also speed-up `energy_detector()`

&nbsp; 

---

### Additional tips

- Use your knowledge about the signal structure to determine the initial range for the tuning parameters in a detection optimization routine
- Make sure reference tables contain all target signals and only the target signals. The performance of the detection cannot be better than the reference itself.
- Avoid having overlapping signals or several signals as a single one (like a multi-syllable vocalization) in the reference table when running an energy-based detector



<div class="alert alert-info">

Please cite [ohun](https://github.com/maRce10/ohun) like this:

Araya-Salas, M. (2021), *ohun: automatic detection of acoustic signals*. R package version 0.1.0.

</div>

```{r, eval = FALSE, echo=FALSE}
Observaciones:

avoid having overlapping selections in reference (check with overlapping_sels())

downsample to a freq range just enough for the signals of interest

use hop.size instead of wl

after split_acoustic_data() another function that returns the position in the original unsplit sound file

count number of detections per unit of time
```



## References

1. Araya-Salas, M. (2021), ohun: automatic detection of acoustic signals. R package version 0.1.0.
1. Araya-Salas M, Smith-Vidaurre G (2017) warbleR: An R package to streamline analysis of animal acoustic signals. Methods Ecol Evol 8:184-191.
1. Khanna H., Gaunt S.L.L.  & McCallum D.A. (1997). Digital spectrographic cross-correlation: tests of sensitivity. Bioacoustics 7(3): 209-234.
1. Macmillan, N. A., & Creelman, C.D. (2004). Detection theory: A user's guide. Psychology press.


&nbsp; 

---

<font size="4">Session information</font>
```{r session info, echo=F}

sessionInfo()

```

