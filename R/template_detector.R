#' @title Acoustic template detection from time-frequency cross-correlations
#'
#' @description \code{template_detector} find sound event occurrences in cross-correlation vectors from \code{\link{template_correlator}}
#' @usage template_detector(template.correlations, cores = 1, threshold, pb = TRUE,
#'  verbose = TRUE)
#' @param template.correlations object of class 'template_correlations' generated by \code{\link{template_correlator}} containing the correlation score vectors.
#' @param cores Numeric. Controls whether parallel computing is applied.
#' It specifies the number of cores to be used. Default is 1 (i.e. no parallel computing).
#' @param threshold Numeric vector of length 1 with a value between 0 and 1 specifying the correlation threshold for detecting sound event occurrences (i.e. correlation peaks). Must be supplied. Correlation scores are forced to between 0 and 1 (by converting negative scores to 0). 0 and 1 represent the lowest and highest similarity to the template respectively.
#' @param pb Logical argument to control progress bar. Default is \code{TRUE}.
#' @param verbose Logical argument to control if some summary messages are printed to the console.
#' @return The function returns a 'selection_table' (warbleR package's formats, see \code{\link[warbleR]{selection_table}}) or data frame (if sound files can't be found) with the start and end and correlation score for the
#' detected sound events.
#' @export
#' @name template_detector
#' @details This function infers sound events occurrences from cross-correlation scores along sound files. Correlation scores must be generated first using \code{\link{template_correlator}}. The output is a data frame (or selection table if sound files are still found in the original path supplied to \code{\link{template_correlator}}, using the warbleR package's format, see \code{\link[warbleR]{selection_table}}) containing the start and end of the detected sound events as well as the cross-correlation score ('scores' column) for each detection. \strong{Note that the detected sounds are assumed to have the same duration as the template, so their start and end correspond to the correlation peak position +/- half the template duration}.
#' @examples
#' {
#' # load example data
#' data("lbh1", "lbh2", "lbh_reference")
#'
#' # save sound files
#' writeWave(lbh1, file.path(tempdir(), "lbh1.wav"))
#' writeWave(lbh2, file.path(tempdir(), "lbh2.wav"))
#'
#' # template for the first sound file in 'lbh_reference'
#' templ1 <- lbh_reference[1, ]
#'
#' # generate template correlations
#' tc <- template_correlator(templates = templ1, path = tempdir(), files = "lbh1.wav")
#'
#' # template detection
#' td <- template_detector(template.correlations = tc, threshold = 0.4)
#'
#' # diagnose detection
#' diagnose_detection(reference =
#' lbh_reference[lbh_reference$sound.files == "lbh1.wav", ],
#' detection = td)
#'
#' # template for the second and third sound file in 'lbh_reference'
#' # which have similar song types
#' templ2 <- lbh_reference[4, ]
#'
#' # generate template correlations
#' tc <- template_correlator(templates = templ2, path = tempdir(),
#' files = c("lbh1.wav", "lbh2.wav"))
#'
#' # template detection
#' td <- template_detector(template.correlations = tc, threshold = 0.3)
#'
#' # diagnose detection
#' diagnose_detection(reference = lbh_reference, detection = td)
#' }
#' @seealso \code{\link{energy_detector}}, \code{\link{template_correlator}}, \code{\link{optimize_template_detector}}
#' @author Marcelo Araya-Salas \email{marcelo.araya@@ucr.ac.cr})
#'
#' @references {
#' Araya-Salas, M. (2021), ohun: diagnosing and optimizing automated sound event detection. R package version 0.1.0.
#' }
# last modification on jan-03-2020 (MAS)
template_detector <-
  function(template.correlations,
           cores = 1,
           threshold,
           pb = TRUE,
           verbose = TRUE)
  {
    # save start time
    start_time <- proc.time()

    # check xc.output being a autodetec.output object
    if (!(is(template.correlations, "template_correlations")))
      stop2("'template.correlations' must be and object of class 'template_correlations'")

    #if threshold is not vector or length!=1 stop
    if (!is.numeric(threshold))
      stop2("'threshold' must be a numeric vector of length 1")
    if (!is.vector(threshold))
      stop2("'threshold' must be a numeric vector of length 1")
    if (!length(threshold) == 1)
      stop2("'threshold' must be a numeric vector of length 1")
    if (threshold >= 1 | threshold <= 0)
      stop2("'threshold' must be a number between 0 and 1")

    # set clusters for windows OS or more decent OSs
    if (Sys.info()[1] == "Windows" & cores > 1)
      cl <-
        parallel::makePSOCKcluster(getOption("cl.cores", cores)) else
      cl <- cores

    # loop over scores of each dyad
    sel_table_list <-
      warbleR:::pblapply_wrblr_int(
        pbar = pb,
        X = 1:(length(template.correlations) - 1),
        cl = cl,
        FUN = function(i) {
          # extract data for a dyad
          temp_cor <- template.correlations[[i]]

          ## get peaks as the ones higher than previous and following scores
          peak_position <-
            which(c(FALSE, diff(temp_cor$correlation.scores) > 0) &
                    c(rev(diff(
                      rev(temp_cor$correlation.scores)
                    ) > 0), FALSE) & temp_cor$correlation.scores > threshold)

          # get peaks and their scores
          scores <- temp_cor$correlation.scores[peak_position]
          peak_time <-
            seq(0,
                temp_cor$file.duration,
                length.out = length(temp_cor$correlation.scores))[peak_position]

          # get peak position fixing by removing half the duration of the sound event at the start and end of the sound file
          peak_time <-
            seq(
              temp_cor$template.duration / 2,
              temp_cor$file.duration - temp_cor$template.duration / 2,
              length.out = length(temp_cor$correlation.scores)
            )[peak_position]

          # get file and template names
          file_template <-
            strsplit(names(template.correlations)[i], "/")[[1]]

          # calculate starts as the peak location minus half the template duration
          starts <-
            if (length(peak_time) > 0)
              peak_time - (temp_cor$template.duration / 2) else
            NA
          # cannot be negative
          starts[starts < 0] <- 0

          # calculate starts as the peak location minus half the template duration
          ends <-
            if (length(peak_time) > 0)
              peak_time + (temp_cor$template.duration / 2) else
            NA

          # cannot be higher than file duration
          ends[ends > temp_cor$file.duration] <- temp_cor$file.duration

          # put results in an extended selection table
          sel_table <-
            data.frame(
              sound.files = file_template[2],
              selec = if (length(scores) > 0)
                seq_len(length(scores)) else
                1,
              start = starts,
              end = ends,
              template = file_template[1],
              scores = if (length(scores) > 0)
                scores else
                NA
            )

          return(sel_table)
        }
      )

    # put results in a data frame
    sel_table_df <- do.call(rbind, sel_table_list)

    # relabel rows
    rownames(sel_table_df) <- 1:nrow(sel_table_df)

    # get path from corrrelation call
    corr_call_path <-
      try(eval(rlang::call_args(template.correlations$call_info$call)$path), silent = TRUE)

    if (is(corr_call_path, 'try-error') |
        is.null(corr_call_path))
      corr_call_path <- getwd()

    #  if no detections
    if (all(is.na(sel_table_df$start)) & verbose)
      print(x = "no sound events above threshold were detected") else
      if (all(sel_table_df$sound.files %in% list.files(path = corr_call_path)) &
          all(!is.na(sel_table_df$start))) {
        sel_table_df <-
          selection_table(
            X = sel_table_df[!is.na(sel_table_df$start),],
            path = corr_call_path,
            parallel = cores,
            pb = FALSE,
            verbose = FALSE,
            fix.selec = TRUE
          )

        attributes(sel_table_df)$call <- base::match.call()

        # add elapsed time
        attributes(sel_table_df)$elapsed.time.s <-
          as.vector((proc.time() - start_time)[3])
      }
    return(sel_table_df)
  }
